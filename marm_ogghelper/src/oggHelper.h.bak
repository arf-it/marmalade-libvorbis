#include <stdio.h>
#include <stdlib.h>
#include <math.h>

#ifdef _USELIBTREMOR
#include <ivorbiscodec.h>
#define OV_EXCLUDE_STATIC_CALLBACKS
#include <ivorbisfile.h>
#else
#include <vorbis/codec.h>
#define OV_EXCLUDE_STATIC_CALLBACKS
#include <vorbis/vorbisfile.h>
#endif

//#ifdef _WIN32 /* We need the following two to set stdin/stdout to binary */
//#include <io.h>
//#include <fcntl.h>
//#endif
#include <string>
#include <pthread.h>
#include "s3eFile.h"
#include <vector>


#define _CONVSIZE_ 4096
#define _CIRCBUFSIZE_	262144


class CThread
{
public:
	CThread();
	int Start(void * arg);
	int Suspend();
	int Cancel();

protected:
	int Run(void * arg);
	static void* EntryPoint(void*);
	void Setup();
	void Execute(void*);
	void * Arg() const {return Arg_;}
	void Arg(void* a){Arg_ = a;}
private:
	pthread_t ThreadId_;
	void * Arg_;
};

//original code from this class cames from: http://bytes.com/topic/c/answers/443602-how-create-circular-queue-c
class CCircularBuffer
{
public:
	enum ERRORS {
		BUFF_EMPTY = -1
	};
	CCircularBuffer (unsigned int size);
	bool read (ogg_int16_t& result);
	bool write (ogg_int16_t value);
	void clear();

	bool BufferIsEmpty() const { return bBufferIsEmpty; };
	bool BBufferIsFull() const { return bBufferIsFull; };

	//bool bBufferIsNotEmpty();
	//bool bBufferIsNotFull();

	unsigned int get_freespace();
	unsigned int get_bufferSize() const { return iBufferSize; }

private:
	std::vector<ogg_int16_t> aInternalBuffer;
	unsigned int iBufferSize;
	unsigned int rIdx;
	unsigned int wIdx;
	bool bBufferIsEmpty;
	bool bBufferIsFull;
	unsigned int iUnread; // index for test functions
};

//---------------------------------------------------------------------------
// template class Queue
//---------------------------------------------------------------------------
template <class T> class Queue {

	T *qbuf;   // buffer data
	int qsize; // 
	int head;  // index begin data
	int tail;  // index stop data

	inline void Free()
	{
		if (qbuf != 0)
		{
			delete []qbuf;
			qbuf= 0;
		}
		qsize= 1;
		head= tail= 0;
	}

public:
	Queue()
	{
		qsize= 32;
		qbuf= new T[qsize];
		head= tail= 0;
	}

	Queue(const int size): qsize(1), qbuf(0), head(0), tail(0)
	{
		if ((size <= 0) || (size & (size - 1)))
		{
			return;
		}

		qsize= size;
		qbuf= new T[qsize];
		head= tail= 0;
	}

	~Queue()
	{
		Free();
	}

	bool Enqueue(const T &p)
	{
		if (IsFull()) 
		{
			return false;
		}

		qbuf[tail]= p;
		tail= (tail + 1) & (qsize - 1);
		return true;
	}

	// Retrieve the item from the queue
	bool Dequeue(T &p)
	{
		if (IsEmpty())
		{
			return false;
		}

		p= qbuf[head];
		head= (head + 1) & (qsize - 1);
		return true;
	}

	// Get i-element with not delete
	bool Peek(const int i, T &p) const
	{
		int j= 0;
		int k= head;
		while (k != tail)
		{
			if (j == i) break;
			j++;

			k= (k + 1) & (qsize - 1);
		}
		if (k == tail) return false;
		p= qbuf[k];
		return true;
	}

	// Size must by: 1, 2, 4, 8, 16, 32, 64, ..
	bool Resize(const int size)
	{
		if ((size <= 0) || (size & (size - 1)))
		{
			return false;
		}

		Free();
		qsize= size;
		qbuf= new T[qsize];
		head= tail= 0;
		return true;
	}

	inline void Clear(void) { head= tail= 0; }

	inline int  GetCapacity(void) const { return (qsize - 1); }

	// Count elements
	inline int  GetBusy(void) const   { return ((head > tail) ? qsize : 0) + tail - head; }

	// true - if queue if empty
	inline bool IsEmpty(void) const { return (head == tail); }

	// true - if queue if full
	inline bool IsFull(void) const  { return ( ((tail + 1) & (qsize - 1)) == head ); }

};

class COggVorbisFileHelper
{
protected:
	char convbuffer[_CONVSIZE_]; /* take 4k out of the data segment, not the stack */
	unsigned int cb_pos;
	unsigned int cb_size;

	OggVorbis_File	vf;
	vorbis_info		*vi;

	ogg_int64_t		nSamples;
	long			nRate;
	int				nChannels;
	int				current_section;

	s3eFile*			oggvorbis_filein;
	//CCircularBuffer*	mDecBuffer;
	Queue<ogg_int16_t> *mDecBuffer; 
	CThread				mDecThread;
	std::string			m_strLastError;
	std::string			m_strStatus;
	bool	m_bStopDecoding;
	int		nSoundChannel;
	int32	nOutputRate;
	int		bOutputIsStereo;
	float	dResampleFactor;
	int		nW, nL;             // Interpolation and decimation factors

	double	time_length;
	double	current_time;

public:
	
	COggVorbisFileHelper();
	~COggVorbisFileHelper();

	enum
	{
		ERR = 0,
		EOK = 1,
		EOS	= 2,
		BFF = 3,
		EBUFFCOMP = 4
	};

	enum OHStatus
	{
		OH_NAN			= 0,
		OH_READY		= 1,
		OH_PLAYING		= 2,
		OH_STOPPED		= 3,
		OH_PAUSED		= 4,
		OH_ERROR		= 5,
		OH_BUFFERING	= 6
	} nStatus;

	enum STEREO_MODE
	{
		STEREO_MODE_MONO,
		STEREO_MODE_BOTH,
		STEREO_MODE_LEFT,
		STEREO_MODE_RIGHT,
		STEREO_MODE_COUNT
	};

	enum SAMPLE_RATE_CONVERTER
	{
		NO_RESAMPLE,
		ZERO_ORDER_HOLD,
		FIRST_ORDER_INTERPOLATION,
		QUADRATIC_INTERPOLATION,
	};

	int get_status() const { return nStatus; };
	int get_decbufspace() { if(mDecBuffer)return mDecBuffer->GetBusy();return 0;};
	bool init(std::string fin_str);
	bool play();
	bool stop();
	bool pause();
	bool resume();

	void cleanup();
	
	int get_nChannels(){return nChannels;};
	long get_rate(){return nRate;};
	int32 get_outputrate(){return nOutputRate;};
	float get_dResampleFactor() const { return dResampleFactor; };

	int get_outputIsStereo() const {return bOutputIsStereo;};
	void set_outputIsStereo(int val){ bOutputIsStereo = val;};
	
	STEREO_MODE get_outputStereoMode() const {return stereoOutputMode;};
	bool set_outputStereoMode(STEREO_MODE val);

	SAMPLE_RATE_CONVERTER get_conversionType() const {return conversionType;};
	void set_conversionType(SAMPLE_RATE_CONVERTER val){ conversionType = val;};

	double get_time_length() {return time_length;};
	double get_current_time(){return current_time;};
	bool set_current_timepos(double pos);

	
	ogg_int64_t get_nsamples() const { return nSamples; };
	ogg_int16_t get_sample();

	void decode_loop();

	int Wait_counter() const { return wait_counter; }
	void Wait_counter(int val) { wait_counter = val; }

	std::string GetStatus() const { return m_strStatus; }
	void SetStatus(std::string val) { m_strStatus = val; }

private:
	STEREO_MODE stereoOutputMode;
	SAMPLE_RATE_CONVERTER conversionType;
	int wait_counter;
	// internal functions 
	int decode();

	

	// oggVorbis loading callbacks
	static size_t read_func(void *ptr, size_t size, size_t nmemb, void *datasource);
	static int seek_func(void *datasource, ogg_int64_t offset, int whence);
	static int close_func(void *datasource);
	static long tell_func(void *datasource);


	long ov_read_func(OggVorbis_File *vf,char *buffer,int length,int bigendianp,int word,int sgned,int *bitstream);
	double ov_time_total_func(OggVorbis_File *vf,int i);
	double ov_time_tell_func(OggVorbis_File *vf);
	int ov_time_seek_func(OggVorbis_File *vf,double pos);


public:
	// streaming callbacks
	static int32 EndSampleCallback(void* sys, void* user);
	static int GenerateAudioCallback(void* sys, void* user);
};
